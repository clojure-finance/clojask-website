<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Clojask: API Docs</title>
        
<meta name="keywords" content="Start">

<meta name="description" content="FeaturesUnlimited size
Theoretically speaking, it supports dataset larger than memory to infinity!All native types
All the datatypes used to store data are native Clojure (or Java) types!From file to file
IO mechanisms are integrated into the dataframe. No need to write your own read-in and output functions!Distributed (coming soon)
Most operations could be distributed to different computers in a clusters. Read about the principle in Onyx.  Lazy operations
Some operations will not be executed immediately. They are stacked in the pipeline which will be optimised for performance when it comes to the final computation step.">

<meta property="og:description" content="FeaturesUnlimited size
Theoretically speaking, it supports dataset larger than memory to infinity!All native types
All the datatypes used to store data are native Clojure (or Java) types!From file to file
IO mechanisms are integrated into the dataframe. No need to write your own read-in and output functions!Distributed (coming soon)
Most operations could be distributed to different computers in a clusters. Read about the principle in Onyx.  Lazy operations
Some operations will not be executed immediately. They are stacked in the pipeline which will be optimised for performance when it comes to the final computation step.">

<meta property="og:url" content="https://clojure-finance.github.io/clojask-website/clojask-website/posts-output/API/" />
<meta property="og:title" content="API Docs" />
<meta property="og:type" content="article" />

        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        
        <link rel="shortcut icon" href="images/ico/favicon.png">
        <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700|Oxygen:300,400,700|Inconsolata" rel="stylesheet">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300&display=swap" rel="stylesheet">
        <link href="/clojask-website/css/normalize.css" rel="stylesheet" type="text/css" />
        <link href="/clojask-website/css/blog.css" rel="stylesheet" type="text/css" />
        <link href="/clojask-website/css/lotus-highlightjs.min.css" rel="stylesheet" type="text/css" />
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/tomorrow-night-eighties.min.css">
    </head>
    <body>
        <aside id="sidebar">
            <div id="logo">
                <a title="Clojask" href="/clojask-website/">
                    <!-- <img class="icon" src="/clojask-website/img/white-lotus.svg"> -->
                    <div class="title-text text desktop-and-tablet-only">
                        <span class="desktop-and-tablet-only fa fa-cubes"></span>
                        <br>
                        <br>
                        Clojask
                    </div>
                    <div class="title-text text mobile-only">Clojask</div>
                </a>
            </div> 

            <nav id="sidebar-links">
                <nav id="menucont">
                    <input type="checkbox" id="menu-checkbox" class="menu-checkbox">
                    <label for="menu-checkbox" class="menutitle">
                        <svg class="icon icon-menu" aria-hidden="true"><use xlink:href="/clojask-website/img/icons.svg#icon-menu"></use></svg><span class="menu-text">Menu</span>
                    </label>
                    <ul class="menu">
                        <li ><a title="Home" href="/clojask-website/"><div class="menu-item-text">Home</div></a></li>
                        <!-- 
                        <li ><a title="Tags" href="/clojask-website/tags/"><div class="menu-item-text">Tags</div></a></li>
                         -->
                        
                        <li >
                            <a href="/clojask-website/pages-output/about/"><div class="menu-item-text">About</div></a>
                        </li>
                        
                         <!-- custom navbar item -->
                        <li>
                            <a title="Getting Started" href="/clojask-website/posts-output/get-started/"><div class="menu-item-text">Getting Started</div></a>
                        </li>
                        <li>
                            <a title="API Docs" href="/clojask-website/posts-output/API/"><div class="menu-item-text">API Docs</div></a>
                        </li>
                        <li>
                            <a title="Examples" href="/clojask-website/posts-output/examples/"><div class="menu-item-text">Examples</div></a>
                        </li>
<!-- 
                        <button class="dropdown">Dropdown
                            <i class="fa fa-caret-down"></i>
                        </button>
                        <div class="dropdown-container">
                            <a href="#">Link 1</a>
                            <a href="##">Link 2</a>
                            <a href="###">Link 3</a>
                        </div>
                        </a> -->

                        <li ><a title="Archives" href="/clojask-website/archives/"><div class="menu-item-text">Archives</div></a></li>
                        <!-- <li><a title="RSS" href="/clojask-website/feed.xml"><div class="menu-item-text">RSS</div></a></li> -->
                    </ul>
                </nav>

                <nav id="socialmedia">
                    <ul>
                        <li><a title="GitHub" href="https://github.com/clojure-finance/clojask" rel="external"><svg class="icon icon-github-circled"><use xlink:href="/clojask-website/img/icons.svg#icon-github-circled"></use></svg></a></li>
                    </ul>
                </nav>
            </nav>
        </aside>

        <article id="main">
            
<div id="post">
    <div class="post-header">
    <div id="post-meta">
        <h1>API Docs</h1>
        <div class="byline">
            <!-- <span class="date">28 September 2021</span> -->
            
        </div>
    </div>
</div>
<div>
    <ul class="toc"><li><a href="#features">Features</a></li><li><a href="#basic-information">Basic Information</a></li><li><a href="#api-documentation">API Documentation</a></li><ul><li><a href="#reorder-col--rename-col">reorder-col / rename-col</a></li><li><a href="#select-col">select-col</a></li><li><a href="#delete-col">delete-col</a></li><li><a href="#filter">filter</a></li><li><a href="#set-type">set-type</a></li><li><a href="#set-parser">set-parser</a></li><li><a href="#operate-in-place-modification">operate (In-place modification)</a></li><li><a href="#operate-column-generating">operate (Column generating)</a></li><li><a href="#group-by">group-by</a></li><li><a href="#aggregate">aggregate</a></li><li><a href="#aggregation-functions">Aggregation Functions</a></li><ul><li><a href="#how-to-define-group-by-aggregation-functions">How to define group-by aggregation functions?</a></li><li><a href="#how-to-define-simple-aggregation-functions">How to define simple aggregation functions?</a></li></ul><li><a href="#sort">sort</a></li><li><a href="#compute">compute</a></li><li><a href="#inner-join--left-join--right-join">inner-join / left-join / right-join</a></li><li><a href="#rolling-join-forwardrolling-join-backward">rolling-join-forward/rolling-join-backward</a></li></ul></ul>
    <h3 id="features">Features</h3><ul><li><p><strong>Unlimited size</strong><br />
Theoretically speaking, it supports dataset larger than memory to infinity!</p></li><li><p><strong>All native types</strong><br />
All the datatypes used to store data are native Clojure (or Java) types!</p></li><li><p><strong>From file to file</strong><br />
IO mechanisms are integrated into the dataframe. No need to write your own read-in and output functions!</p></li><li><p><strong>Distributed (coming soon)</strong><br />
Most operations could be distributed to different computers in a clusters. Read about the principle in <a href="http://www.onyxplatform.org/">Onyx</a>.  <br /></p></li><li><p><strong>Lazy operations</strong><br />
Some operations will not be executed immediately. They are stacked in the pipeline which will be optimised for performance when it comes to the final computation step.</p></li></ul><hr /><h3 id="basic-information">Basic Information</h3><ul><li>Most dataframe manipulation operations are performed lazily (except <code>sort</code> and <code>join</code>). They will be executed all at once when <code>compute</code> is called.</li><li>The dataframe traverses the data in rows, with each row represented by a vector.</li><li>The size of the input dataframe can be larger than the size of available memory in the machine.</li><li>By default, all columns are assigned with the data type <code>string</code> when the dataframe is first imported. You are allowed to change its type using our predefined type keywords.</li></ul><hr /><h2 id="api-documentation">API Documentation</h2><hr /><h4 id="reorder-col--rename-col">reorder-col / rename-col</h4><p>Reorder the columns / rename the column names in the dataframe</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>columns</code></td><td>Clojure.collection</td><td>The new set of column names</td><td>Should be existing set of column names in dataframe if it is <code>reorder-col</code></td></tr></tbody></table><pre><code class="clojure">;; columns: ["Employee" "EmployeeName" "Department" "Salary"]
(rename-col x ["Employee" "EmployeeName" "new-Department" "Salary"])
;; columns: ["Employee" "EmployeeName" "new-Department" "Salary"]
(reorder-col x ["Employee" "new-Department" "EmployeeName" "Salary"])
</code></pre><hr /><h4 id="select-col">select-col</h4><p>Select columns to keep and get rid of other unselected columns in the dataframe.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>columns</code></td><td>Clojure.collection</td><td>The set of columns names to keep</td><td>Should be existing columns within the dataframe</td></tr></tbody></table><pre><code class="clojure">;; columns: ["Employee" "EmployeeName" "Department" "Salary"]
(select-col x ["Employee" "Department"])
</code></pre><hr /><h4 id="delete-col">delete-col</h4><p>Eliminate a set of column(s) in the dataframe.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>columns</code></td><td>Clojure.collection</td><td>The set of columns names to eliminate</td><td>Should be existing column(s) within the dataframe</td></tr></tbody></table><pre><code class="clojure">;; columns: ["Employee" "EmployeeName" "Department" "Salary"]
(delete-col x ["EmployeeName" "Salary"])
</code></pre><hr /><h4 id="filter">filter</h4><p>Filter the dataframe by rows.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>columns</code></td><td>String / collection of strings</td><td>The columns that the predicate function would apply to</td><td> </td></tr><tr><td><code>predicate</code></td><td>Function</td><td>The predicate function to determine if a row should be kept</td><td>This function should have the same number of arguments with the above columns and in the same order. Only rows that return <code>true</code> will be kept.</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(filter x "Salary" (fn [salary] (&lt;= salary 800)))
;; this statement deletes all the rows that have a salary larger than 800
(filter x ["Salary" "Department"] (fn [salary dept] (and (&lt;= salary 800) (= dept "computer science"))))
;; keeps only people from computer science department with salary not larger than 800
</code></pre><hr /><h4 id="set-type">set-type</h4><p>Set the data type of a column. As a result, the value will be parsed as the assigned data type when it is used in any subsequent operations.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>column</code></td><td>String</td><td>Target columns</td><td>Should be existing columns within the dataframe.</td></tr><tr><td><code>type</code></td><td>String</td><td>Type of the column</td><td>The natively supported types are: int, double, string, date. Note that by default all the column types are string. If you need a special parsing function, see <code>add-parser</code>.</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">;; set data type of the column "Salary" to be double
(set-type x "Salary" "double")
</code></pre><hr /><h4 id="set-parser">set-parser</h4><p>A more flexible way to set type.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>column</code></td><td>String</td><td>Target columns</td><td>Should be existing columns within the dataframe</td></tr><tr><td><code>parser</code></td><td>function</td><td>The parser function that will parse a string to other types (or even string)</td><td>The function should take only one argument which is a string, and the parsed type should be serializable.</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">;; parse all the values in "Salary" with this function
(set-parser x "Salary" #(Double/parseDouble %))
</code></pre><hr /><h4 id="operate-in-place-modification">operate (In-place modification)</h4><p><strong>In-place modification</strong> on a single column</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>operation</code></td><td>function</td><td>Function to be applied lazily</td><td>The function should take only one argument which is the value of the below column.</td></tr><tr><td><code>column name</code></td><td>Keyword</td><td>Target columns</td><td>Should be existing columns within the dataframe.</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">;; set data type as double
(set-type x "Salary" "double")
;; take the negative of the column "Salary"
(operate x - "Salary")
</code></pre><hr /><h4 id="operate-column-generating">operate (Column generating)</h4><p>Calculate the result and store in a new column</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>operation</code></td><td>function</td><td>Function to be applied lazily</td><td>Argument number should align with the number of column names below, ie <em>if operation functions takes two arguments, the length of column names should also be two, and in the same order that is passed to the function</em>.</td></tr><tr><td><code>column name(s)</code></td><td>String or collection of String</td><td>Target columns</td><td>Should be existing columns within the dataframe.</td></tr><tr><td><code>new column</code></td><td>String</td><td>Resultant column</td><td>Should be new column(s) other than those existing in the dataframe.</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(operate x str ["Employee" "EmployeeName"] "new")
;; concats the two columns into the "new" column
</code></pre><hr /><h4 id="group-by">group-by</h4><p>Group the dataframe by some specific columns (always used together with <code>aggregate</code>), or group the dataframe by function output(s)</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>groupby-keys</code></td><td>String / Collection</td><td>Group by columns (functions of columns)</td><td>Find the specification <a href="#groupby-keys">here</a>.</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">;; group by one or more columns
(group-by x ["Department"])
(group-by x ["Department" "DepartmentName"])
</code></pre><p><a name="groupby-keys"><strong>Group-by Keys Specification</strong></a></p><p><strong>Group-by functions requirements:</strong></p><ul><li>Take one argument</li><li>Return type: int / double / string</li></ul><p>One general rule is to put the group-by function and its corresponding column name together.</p><pre><code class="clojure">(defn rem10
  "Get the reminder of the num by 10"
  [num]
  (rem num 10))

(group-by x [rem10 "Salary"])
;; or
(group-by x [[rem10 "Salary"]])
</code></pre><p>If no group-by function, the column name can be alone.</p><pre><code class="clojure">(group-by x "Salary")
;; or
(group-by x ["Salary"])
</code></pre><p>You can also group by the combination of keys. (Use the above two rules together)</p><pre><code class="clojure">(group-by x [[rem10 "Salary"] "Department"])
;; or
(group-by x [[rem10 "Salary"] ["Department"]])
</code></pre><hr /><h4 id="aggregate">aggregate</h4><p>Aggregate the dataframe(s) by applying some functions. The aggregation function will be applied to every column registered in sequence.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>aggregation function</code></td><td>function</td><td>Function to be applied to each column</td><td>Should take a collection as argument. And return one or a collection of predefined type*.</td></tr><tr><td><code>column name(s)</code></td><td>String or collection of String</td><td>Aggregate columns</td><td>Should be existing columns within the dataframe</td></tr><tr><td>[<code>new column</code>]</td><td>String or collection of string</td><td>Resultant column</td><td>Should be new columns not in the dataframe</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">;; get the min of the selected column(s)
(aggregate x clojask/max ["Salary"] ["Salary-min"])
(aggregate x clojask/min ["Employee" "EmployeeName"] ["Employee-min" "EmployeeName-min"])
</code></pre><h4 id="aggregation-functions">Aggregation Functions</h4><p>In Clojask, you can aggregate the whole dataframe or aggregate the grouped by dataframe(s). The former could be known as "simple aggregation", and the latter as "group-by aggregation". Some given functions for simple aggregation are defined in the namespace <code>clojask.api.aggregate</code>, and the given functions for group-by aggregation are defined in the namespace <code>clojask.api.gb-aggregate</code>.</p><p>Below is the full list of given functions for the two types of aggregation.</p><p><code>clojask.api.aggregate</code>:</p><p><code>max</code>: Find the max value (use <code>clojure.core/compare</code> as the comparator)</p><p><code>min</code>: Find the min value (use <code>clojure.core/compare</code> as the comparator)
<br />
*Note that the default behaviour for <code>clojask/min</code> is that <code>null</code> could be returned as a minimal value.</p><p><code>clojask.api.gb-aggregate</code>:</p><p><code>max</code>: Find the max value (use <code>clojure.core/compare</code> as the comparator)</p><p><code>min</code>: Find the min value (use <code>clojure.core/compare</code> as the comparator)</p><p>In addition to these given functions, you are also welcomed to define your own aggregation function.</p><h5 id="how-to-define-group-by-aggregation-functions">How to define group-by aggregation functions?</h5><p>This is the template:</p><pre><code class="clojure">(defn gb-aggre-template
  [col]  ;; take only one argument which is the aggregation column in the format of vector
  ;; ... your implementation
  result    ;; return one variable (could be int / double / string / collection of above)
  )
</code></pre><p>Basically, the function should take one argument only, which is the full aggregation column. <em><strong>Here we simply assume this column should be smaller than memory!</strong></em></p><p>You may find many built-in function in Clojure also fulfilling this requirement, for example, <code>count</code>, <code>mean</code>, and countless function constructed from <a href="https://clojuredocs.org/clojure.core/reduce"><code>reduce</code></a>.</p><h5 id="how-to-define-simple-aggregation-functions">How to define simple aggregation functions?</h5><p>This is the template:</p><pre><code class="clojure">(defn aggre-template
  ;; [new-value old-result]
  [old-result new-value]
  ;; old-result: the value of the result for the previous gb-aggre-template
  ;; new-value: the value for the column on the current row
  ;; ... your implementation
  new-result   ;; return the new result, and this will be passed as old-result for the next gb-aggre-template
  )
</code></pre><p><strong>Notes:</strong></p><ol><li>The old-result for the first <code>aggre-template</code> is <code>clojask.api.aggregate/start</code>. So your function must be able to deal with cases when the first argument is <code>clojask.api.aggregate/start</code>.</li><li>Your function should be self-sustainable, meaning that the result of <code>aggre-template</code> should be safe as the input for <code>aggre-template</code>.
<ol><li>To better understand the this template, you may refer to the documentation of <a href="https://clojuredocs.org/clojure.core/reduce"><code>reduce</code></a>, the <code>aggre-func</code> should be able to use in <code>reduce</code>.</li></ol></li></ol><hr /><h4 id="sort">sort</h4><p><strong>Immediately</strong> sort the dataframe</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>trending list</code></td><td>Collection (seq vector)</td><td>Indicates the sort order</td><td>Example: ["Salary" "+" "Employee" "-"] means that sort the Salary in ascending order, if equal sort then by Employee in descending order</td></tr><tr><td><code>output-directory</code></td><td>String</td><td>The output path</td><td> </td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">;; sort by "Salary" in ascending order
(sort x ["+" "Salary"] "path/output.csv")
</code></pre><hr /><h4 id="compute">compute</h4><p>Compute the result. The pre-defined lazy operations will be executed in the pipeline, i.e. the result of the previous operation becomes the argument of the next operation.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>num of workers</code></td><td>int (max 8)</td><td>The number of worker instances (except the input and output nodes)</td><td>If this argument &gt;= 2, will use <a href="http://www.onyxplatform.org/">onyx</a> as the distributed platform</td></tr><tr><td><code>output path</code></td><td>String</td><td>The path of the output csv file</td><td>Could exist or not.</td></tr><tr><td>[<code>exception</code>]</td><td>boolean</td><td>Whether an exception during calculation will cause termination</td><td>Is useful for debugging or detecting empty fields</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">;; compute all pre-registered operations
(compute x 8 "path/output.csv" :exception true)
</code></pre><hr /><h4 id="inner-join--left-join--right-join">inner-join / left-join / right-join</h4><p>Inner / left / right join two dataframes on specific columns</p><p><em>Remarks:</em></p><p><em>Join functions are immediate actions that will be executed once they are being called.</em></p><p><em>The registered operations and filters (like <code>compute</code>) will be automatically pipelined. You could think of <code>join</code> as as an operation that first computes the two dataframes then joins them together.</em></p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe a</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>dataframe b</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>a columns</code></td><td>Clojure.collection</td><td>The keys of a to be aligned</td><td>Should be existing headers in dataframe a</td></tr><tr><td><code>b columns</code></td><td>Clojure.collection</td><td>The keys of b to be aligned</td><td>Should be existing headers in dataframe b</td></tr><tr><td><code>number of workers</code></td><td>int (max 8)</td><td>Number of worker nodes doing the joining</td><td> </td></tr><tr><td><code>distination file</code></td><td>string</td><td>The file path to the distination</td><td>Will be emptied first</td></tr><tr><td>[<code>exception</code>]</td><td>boolean</td><td>Whether an exception during calculation will cause termination</td><td>Is useful for debugging or detecting empty fields</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(def x (dataframe "path/to/a"))
(def y (dataframe "path/to/b"))

(inner-join x y ["col_a1" "col_a2"] ["col_b1" "col_b2"] 8 "path/to/distination" :exception true)
;; inner join x and y

(left-join x y ["col_a1" "col_a2"] ["col_b1" "col_b2"] 8 "path/to/distination" :exception true)
;; left join x and y

(right-join x y ["col_a1" "col_a2"] ["col_b1" "col_b2"] 8 "path/to/distination" :exception true)
;; right join x and y
</code></pre><hr /><h4 id="rolling-join-forwardrolling-join-backward">rolling-join-forward/rolling-join-backward</h4><p>Rolling join two dataframes on columns</p><p><em>Remarks:</em></p><p><em>Join functions are immediate actions that will be executed once they are being called.</em></p><p><em>The registered operations and filters (like <code>compute</code>) will be automatically pipelined. You could think of <code>join</code> as as an operation that first computes the two dataframes then joins them together.</em></p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe a</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>dataframe b</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>a columns</code></td><td>Clojure.collection</td><td>The keys of a to be aligned</td><td>Should be existing headers in dataframe a</td></tr><tr><td><code>b columns</code></td><td>Clojure.collection</td><td>The keys of b to be aligned</td><td>Should be existing headers in dataframe b</td></tr><tr><td><code>number of workers</code></td><td>int (max 8)</td><td>Number of worker nodes doing the joining</td><td> </td></tr><tr><td><code>distination file</code></td><td>string</td><td>The file path to the distination</td><td>Will be emptied first</td></tr><tr><td>[<code>exception</code>]</td><td>boolean</td><td>Whether an exception during calculation will cause termination</td><td>Is useful for debugging or detecting empty fields</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(def x (dataframe "path/to/a"))
(def y (dataframe "path/to/b"))

(rolling-join-forward x y ["Employee"] ["Employee"] "Salary" "Salary" 8 "path/output.csv" :exception true)
(rolling-join-forward x y ["Employee"] ["Employee"] "Salary" "Salary" 8 "path/output.csv" :exception true)
</code></pre>
</div>
<!--  -->
<!-- <br/> -->


    <!-- 
    <div id="prev-next">
    
    <a class="prev" href="/clojask-website/posts-output/examples/"><svg class="icon icon-circle-left"><use xlink:href="/clojask-website/img/icons.svg#icon-circle-left"></use></svg><div class="nav-text">Examples</div></a>
    
    
    <div class="next"></div>
    
</div>

     -->

    


</div>

            <!-- <hr/> -->
            <br/>
            <div id="footercont">
                Copyright &copy; 2021 Clojask
                <br>Powered by <a href="http://cryogenweb.org">Cryogen</a>
            </div>
        </article>

        <script src="/clojask-website/js/highlight.pack.js" type="application/javascript"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script src="/clojask-website/js.dropdown.js" type="application/javascript"></script> 
        

        
        
    </body>
</html>
