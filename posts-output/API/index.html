<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Clojask: API Docs</title>
        
<meta name="keywords" content="Start">

<meta name="description" content="FeaturesUnlimited size
Theoretically speaking, it supports dataset larger than memory to infinity!All native types
All the datatypes used to store data is native Clojure (or Java) types!From file to file
Integrate IO inside the dataframe. No need to write your own read-in and output functions!Distributed (coming soon)
Most operations could be distributed to different computers in a clusters. See the principle in Onyx  Lazy operations
Some operations will not be executed immediately. Dataframe will intelligently pipeline the operations altogether in computation.">

<meta property="og:description" content="FeaturesUnlimited size
Theoretically speaking, it supports dataset larger than memory to infinity!All native types
All the datatypes used to store data is native Clojure (or Java) types!From file to file
Integrate IO inside the dataframe. No need to write your own read-in and output functions!Distributed (coming soon)
Most operations could be distributed to different computers in a clusters. See the principle in Onyx  Lazy operations
Some operations will not be executed immediately. Dataframe will intelligently pipeline the operations altogether in computation.">

<meta property="og:url" content="https://clojure-finance.github.io/clojask-website/clojask-website/posts-output/API/" />
<meta property="og:title" content="API Docs" />
<meta property="og:type" content="article" />

        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        
        <link rel="shortcut icon" href="images/ico/favicon.png">
        <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700|Oxygen:300,400,700|Inconsolata" rel="stylesheet">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300&display=swap" rel="stylesheet">
        <link href="/clojask-website/css/normalize.css" rel="stylesheet" type="text/css" />
        <link href="/clojask-website/css/blog.css" rel="stylesheet" type="text/css" />
        <link href="/clojask-website/css/lotus-highlightjs.min.css" rel="stylesheet" type="text/css" />
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/tomorrow-night-eighties.min.css">
    </head>
    <body>
        <aside id="sidebar">
            <div id="logo">
                <a title="Clojask" href="/clojask-website/">
                    <!-- <img class="icon" src="/clojask-website/img/white-lotus.svg"> -->
                    <div class="title-text text desktop-and-tablet-only">
                        <span class="desktop-and-tablet-only fa fa-cubes"></span>
                        <br>
                        <br>
                        Clojask
                    </div>
                    <div class="title-text text mobile-only">Clojask</div>
                </a>
            </div> 

            <nav id="sidebar-links">
                <nav id="menucont">
                    <input type="checkbox" id="menu-checkbox" class="menu-checkbox">
                    <label for="menu-checkbox" class="menutitle">
                        <svg class="icon icon-menu" aria-hidden="true"><use xlink:href="/clojask-website/img/icons.svg#icon-menu"></use></svg><span class="menu-text">Menu</span>
                    </label>
                    <ul class="menu">
                        <li ><a title="Home" href="/clojask-website/"><div class="menu-item-text">Home</div></a></li>
                        <!-- 
                        <li ><a title="Tags" href="/clojask-website/tags/"><div class="menu-item-text">Tags</div></a></li>
                         -->
                        
                        <li >
                            <a href="/clojask-website/pages-output/about/"><div class="menu-item-text">About</div></a>
                        </li>
                        
                         <!-- custom navbar item -->
                        <li>
                            <a title="API Docs" href="/clojask-website/posts-output/API/"><div class="menu-item-text">API Docs</div></a>
                        </li>
                        <li>
                            <a title="Examples" href="/clojask-website/posts-output/examples/"><div class="menu-item-text">Examples</div></a>
                        </li>
                        <li ><a title="Archives" href="/clojask-website/archives/"><div class="menu-item-text">Archives</div></a></li>
                        <!-- <li><a title="RSS" href="/clojask-website/feed.xml"><div class="menu-item-text">RSS</div></a></li> -->
                    </ul>
                </nav>

                <nav id="socialmedia">
                    <ul>
                        <li><a title="GitHub" href="https://github.com/clojure-finance/clojask-website" rel="external"><svg class="icon icon-github-circled"><use xlink:href="/clojask-website/img/icons.svg#icon-github-circled"></use></svg></a></li>
                    </ul>
                </nav>
            </nav>
        </aside>

        <article id="main">
            
<div id="post">
    <div class="post-header">
    <div id="post-meta">
        <h1>API Docs</h1>
        <div class="byline">
            <!-- <span class="date">September 28, 2021</span> -->
            
        </div>
    </div>
</div>
<div>
    <ul class="toc"><li><a href="#features">Features</a></li><li><a href="#basic-information">Basic Information</a></li><li><a href="#api-documentation">API Documentation</a></li><ul><li><a href="#filter">filter</a></li><li><a href="#set-type">set-type</a></li><li><a href="#set-parser">set-parser</a></li><li><a href="#operate-in-place-modification">operate (In-place modification)</a></li><li><a href="#operate-column-generating">operate (Column generating)</a></li><li><a href="#group-by">group-by</a></li><li><a href="#aggregate">aggregate</a></li><li><a href="#sort">sort</a></li><li><a href="#compute">compute</a></li><li><a href="#inner-join--left-join--right-join">inner-join / left-join / right-join</a></li><li><a href="#reordercol--renamecol">reorderCol / renameCol</a></li></ul></ul>
    <h3 id="features">Features</h3><ul><li><p><strong>Unlimited size</strong><br />
Theoretically speaking, it supports dataset larger than memory to infinity!</p></li><li><p><strong>All native types</strong><br />
All the datatypes used to store data is native Clojure (or Java) types!</p></li><li><p><strong>From file to file</strong><br />
Integrate IO inside the dataframe. No need to write your own read-in and output functions!</p></li><li><p><strong>Distributed (coming soon)</strong><br />
Most operations could be distributed to different computers in a clusters. See the principle in <a href="http://www.onyxplatform.org/">Onyx</a>  <br /></p></li><li><p><strong>Lazy operations</strong><br />
Some operations will not be executed immediately. Dataframe will intelligently pipeline the operations altogether in computation.</p></li></ul><hr /><h3 id="basic-information">Basic Information</h3><ul><li>Most operations to the dataframe is performed lazily and all at once with <code>compute</code> except <code>sort</code> and <code>join</code>.</li><li>The dataframe process the data in rows, ie one row in one vector.</li><li>The input dataframe can be larger than memory in size.</li><li>By default, all columns have the same type: string. You are allowed to set its type, with our predefined type keywords.</li></ul><hr /><h2 id="api-documentation">API Documentation</h2><hr /><h4 id="filter">filter</h4><p>Filters the data frame by rows</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>columns</code></td><td>String / collection of strings</td><td>The columns the predicate function to apply to</td><td> </td></tr><tr><td><code>predicate</code></td><td>Function</td><td>The predicate function to determine if a row should be kept</td><td>This function should have the same number of arguments with the above columns and in the same order. Only rows that return <code>true</code> will be kept.</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(filter x "Salary" (fn [salary] (&lt;= salary 800)))
;; this statement deletes all the rows that have a salary larger than 800
(filter x ["Salary" "Department"] (fn [salary dept] (and (&lt;= salary 800) (= dept "computer science"))))
;; keeps only people from computer science department with salary not larger than 800
</code></pre><hr /><h4 id="set-type">set-type</h4><p>Set the type of a column. So when using the value of that column, it would be in that type.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>type</code></td><td>String</td><td>Type of the column</td><td>The native support types are: int, double, string, date. Note that by default all the column types are string. If you need special parsing function, see <code>add-parser</code>.</td></tr><tr><td><code>column</code></td><td>String</td><td>Target columns</td><td>Should be existing columns within the dataframe</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(set-type x "double" "Salary")
;; makes the column Salary doubles
</code></pre><hr /><h4 id="set-parser">set-parser</h4><p>A more flexible way to set type.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>parser</code></td><td>function</td><td>The parser function that will parse a string to other types (or even string)</td><td>The function should take only one argument which is a string, and the parsed type should be serializable.</td></tr><tr><td><code>column</code></td><td>String</td><td>Target columns</td><td>Should be existing columns within the dataframe</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(set-parser x Double/parseDouble "Salary")
;; parse all the values in Salary with this function
</code></pre><hr /><h4 id="operate-in-place-modification">operate (In-place modification)</h4><p><strong>In-place modification</strong> on a single column</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>operation</code></td><td>function</td><td>Function to be applied lazily</td><td>The function should take only one argument which is the value of the below column</td></tr><tr><td><code>column name</code></td><td>Keyword</td><td>Target columns</td><td>Should be existing columns within the dataframe</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(set-type x "double" "Salary")
(operate x - "Salary")
;; takes the negative of column Salary
</code></pre><hr /><h4 id="operate-column-generating">operate (Column generating)</h4><p>Calculate the result and store in a new column</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>operation</code></td><td>function</td><td>Function to be applied lazily</td><td>Argument number should be complied with the column names below, ie <em>if operation functions takes two arguments, the length of column names should also be 2, and in the same order to be passed to the function</em></td></tr><tr><td><code>column name(s)</code></td><td>String or collection of String</td><td>Target columns</td><td>Should be existing columns within the dataframe</td></tr><tr><td><code>new column</code></td><td>String</td><td>Resultant column</td><td>Should be new column other than the dataframe</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(operate x str ["Employee" "EmployeeName"] "new")
;; concats the two columns into the "new" column
</code></pre><hr /><h4 id="group-by">group-by</h4><p>Group the dataframe by some particular columns (always use together with <code>aggregate</code>)</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>column name(s)</code></td><td>String or collection of String</td><td>Group by columns</td><td>Should be existing columns within the dataframe</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(group-by x ["Department" "DepartmentName"])
;; group by both columns
</code></pre><h4 id="aggregate">aggregate</h4><p>Aggregate the grouped dataframes with some functions. The aggregation function will be applied to every columns registered in sequence.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>aggregation function</code></td><td>function</td><td>Function to be applied to each column</td><td>Should take a collection as argument. And return one or a collection of predefined type*.</td></tr><tr><td><code>column name(s)</code></td><td>String or collection of String</td><td>Aggregate columns</td><td>Should be existing columns within the dataframe</td></tr><tr><td>[<code>new column</code>]</td><td>String or collection of string</td><td>Resultant column</td><td>Should be new columns not in the dataframe</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(aggregate x clojask/min ["Employee" "EmployeeName"] ["new" "new2"])
;; get the min of the two columns grouped by ...
</code></pre><hr /><h4 id="sort">sort</h4><p><strong>Immediately</strong> sort the dataframe</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>trending list</code></td><td>Collection (seq vector)</td><td>Indicates the sort order</td><td>Example: ["Salary" "+" "Employee" "-"] means that sort the Salary in ascending order, if equal sort the Employee in descending order</td></tr><tr><td><code>output-directory</code></td><td>String</td><td>The output path</td><td> </td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(sort y ["+" "Salary"] "resources/sort.csv")
;; sort by Salary ascendingly
</code></pre><hr /><h4 id="compute">compute</h4><p>Compute the result. The pre-defined lazy operations will be executed in pipeline, i.e. the result of the previous operation becomes the argument of the next operation.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>num of workers</code></td><td>int (max 8)</td><td>The number of worker instances (except the input and output nodes)</td><td>If this argument &gt;= 2, will use <a href="http://www.onyxplatform.org/">onyx</a> as the distributed platform</td></tr><tr><td><code>output path</code></td><td>String</td><td>The path of the output csv file</td><td>Could exist or not.</td></tr><tr><td>[<code>exception</code>]</td><td>boolean</td><td>Whether an exception during calculation will cause termination</td><td>Is useful for debugging or detecting empty fields</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(compute x 8 "../resources/test.csv" :exception true)
;; computes all the pre-registered operations
</code></pre><hr /><h4 id="inner-join--left-join--right-join">inner-join / left-join / right-join</h4><p>Inner / left / right join two dataframes by some columns</p><p><em>Remarks:</em></p><p><em>Join functions are immediate actions, which will be executed at once.</em></p><p><em>Will automatically pipeline the registered operations and filters like <code>compute</code>. You could think of join as first compute the two dataframes then join.</em></p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe a</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>dataframe b</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>a columns</code></td><td>Clojure.collection</td><td>The keys of a to be aligned</td><td>Should be existing headers in dataframe a</td></tr><tr><td><code>b columns</code></td><td>Clojure.collection</td><td>The keys of b to be aligned</td><td>Should be existing headers in dataframe b</td></tr><tr><td><code>number of workers</code></td><td>int (max 8)</td><td>Number of worker nodes doing the joining</td><td> </td></tr><tr><td><code>distination file</code></td><td>string</td><td>The file path to the distination</td><td>Will be emptied first</td></tr><tr><td>[<code>exception</code>]</td><td>boolean</td><td>Whether an exception during calculation will cause termination</td><td>Is useful for debugging or detecting empty fields</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(def x (dataframe "path/to/a"))
(def y (dataframe "path/to/b"))

(inner-join x y ["col a 1" "col a 2"] ["col b 1" "col b 2"] 8 "path/to/distination" :exception true)
;; inner join x and y

(left-join x y ["col a 1" "col a 2"] ["col b 1" "col b 2"] 8 "path/to/distination" :exception true)
;; left join x and y

(right-join x y ["col a 1" "col a 2"] ["col b 1" "col b 2"] 8 "path/to/distination" :exception true)
;; right join x and y
</code></pre><hr /><h4 id="reordercol--renamecol">reorderCol / renameCol</h4><p>Reorder the columns / rename the column names in the dataframe</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe a</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>a columns</code></td><td>Clojure.collection</td><td>The new set of column names</td><td>Should be existing headers in dataframe a if it is <code>reorderCol</code></td></tr></tbody></table><pre><code class="clojure">(.reorderCol y ["Employee" "Department" "EmployeeName" "Salary"])
(.renameCol y ["Employee" "new-Department" "EmployeeName" "Salary"])
</code></pre>
</div>
<!--  -->
<!-- <br/> -->


    <!-- 
    <div id="prev-next">
    
    <a class="prev" href="/clojask-website/posts-output/examples/"><svg class="icon icon-circle-left"><use xlink:href="/clojask-website/img/icons.svg#icon-circle-left"></use></svg><div class="nav-text">Examples</div></a>
    
    
    <div class="next"></div>
    
</div>

     -->

    


</div>

            <!-- <hr/> -->
            <br/>
            <div id="footercont">
                Copyright &copy; 2021 Clojask
                <br>Powered by <a href="http://cryogenweb.org">Cryogen</a>
            </div>
        </article>

        <script src="/clojask-website/js/highlight.pack.js" type="application/javascript"></script>
        <script>hljs.initHighlightingOnLoad();</script>

        
        
    </body>
</html>
