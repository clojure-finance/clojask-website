<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Clojask: API Docs</title>
        
<meta name="keywords" content="Start">

<meta name="description" content="FeaturesUnlimited size
Theoretically speaking, it supports dataset larger than memory to infinity!All native types
All the datatypes used to store data is native Clojure (or Java) types!From file to file
Integrate IO inside the dataframe. No need to write your own read-in and output functions!Distributed (coming soon)
Most operations could be distributed to different computers in a clusters. See the principle in Onyx  Lazy operations
Some operations will not be executed immediately. Dataframe will intelligently pipeline the operations altogether in computation.">

<meta property="og:description" content="FeaturesUnlimited size
Theoretically speaking, it supports dataset larger than memory to infinity!All native types
All the datatypes used to store data is native Clojure (or Java) types!From file to file
Integrate IO inside the dataframe. No need to write your own read-in and output functions!Distributed (coming soon)
Most operations could be distributed to different computers in a clusters. See the principle in Onyx  Lazy operations
Some operations will not be executed immediately. Dataframe will intelligently pipeline the operations altogether in computation.">

<meta property="og:url" content="https://clojure-finance.github.io/clojask-website/clojask-website/posts-output/API/" />
<meta property="og:title" content="API Docs" />
<meta property="og:type" content="article" />

        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        
        <link rel="shortcut icon" href="images/ico/favicon.png">
        <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700|Oxygen:300,400,700|Inconsolata" rel="stylesheet">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300&display=swap" rel="stylesheet">
        <link href="/clojask-website/css/normalize.css" rel="stylesheet" type="text/css" />
        <link href="/clojask-website/css/blog.css" rel="stylesheet" type="text/css" />
        <link href="/clojask-website/css/lotus-highlightjs.min.css" rel="stylesheet" type="text/css" />
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/tomorrow-night-eighties.min.css">
    </head>
    <body>
        <aside id="sidebar">
            <div id="logo">
                <a title="Clojask" href="/clojask-website/">
                    <!-- <img class="icon" src="/clojask-website/img/white-lotus.svg"> -->
                    <div class="title-text text desktop-and-tablet-only">
                        <span class="desktop-and-tablet-only fa fa-cubes"></span>
                        <br>
                        <br>
                        Clojask
                    </div>
                    <div class="title-text text mobile-only">Clojask</div>
                </a>
            </div> 

            <nav id="sidebar-links">
                <nav id="menucont">
                    <input type="checkbox" id="menu-checkbox" class="menu-checkbox">
                    <label for="menu-checkbox" class="menutitle">
                        <svg class="icon icon-menu" aria-hidden="true"><use xlink:href="/clojask-website/img/icons.svg#icon-menu"></use></svg><span class="menu-text">Menu</span>
                    </label>
                    <ul class="menu">
                        <li ><a title="Home" href="/clojask-website/"><div class="menu-item-text">Home</div></a></li>
                        <!-- 
                        <li ><a title="Tags" href="/clojask-website/tags/"><div class="menu-item-text">Tags</div></a></li>
                         -->
                        
                        <li >
                            <a href="/clojask-website/pages-output/about/"><div class="menu-item-text">About</div></a>
                        </li>
                        
                         <!-- custom navbar item -->
                        <li>
                            <a title="Getting Started" href="/clojask-website/posts-output/get-started/"><div class="menu-item-text">Getting Started</div></a>
                        </li>
                        <li>
                            <a title="API Docs" href="/clojask-website/posts-output/API/"><div class="menu-item-text">API Docs</div></a>
                        </li>
                        <li>
                            <a title="Examples" href="/clojask-website/posts-output/examples/"><div class="menu-item-text">Examples</div></a>
                        </li>
<!-- 
                        <button class="dropdown">Dropdown
                            <i class="fa fa-caret-down"></i>
                        </button>
                        <div class="dropdown-container">
                            <a href="#">Link 1</a>
                            <a href="##">Link 2</a>
                            <a href="###">Link 3</a>
                        </div>
                        </a> -->

                        <li ><a title="Archives" href="/clojask-website/archives/"><div class="menu-item-text">Archives</div></a></li>
                        <!-- <li><a title="RSS" href="/clojask-website/feed.xml"><div class="menu-item-text">RSS</div></a></li> -->
                    </ul>
                </nav>

                <nav id="socialmedia">
                    <ul>
                        <li><a title="GitHub" href="https://github.com/clojure-finance/clojask" rel="external"><svg class="icon icon-github-circled"><use xlink:href="/clojask-website/img/icons.svg#icon-github-circled"></use></svg></a></li>
                    </ul>
                </nav>
            </nav>
        </aside>

        <article id="main">
            
<div id="post">
    <div class="post-header">
    <div id="post-meta">
        <h1>API Docs</h1>
        <div class="byline">
            <!-- <span class="date">28 September 2021</span> -->
            
        </div>
    </div>
</div>
<div>
    <ul class="toc"><li><a href="#features">Features</a></li><li><a href="#basic-information">Basic Information</a></li><li><a href="#api-documentation">API Documentation</a></li><ul><li><a href="#reorder-col--rename-col">reorder-col / rename-col</a></li><li><a href="#select-col">select-col</a></li><li><a href="#delete-col">delete-col</a></li><li><a href="#filter">filter</a></li><li><a href="#set-type">set-type</a></li><li><a href="#set-parser">set-parser</a></li><li><a href="#operate-in-place-modification">operate (In-place modification)</a></li><li><a href="#operate-column-generating">operate (Column generating)</a></li><li><a href="#group-by">group-by</a></li><li><a href="#aggregate">aggregate</a></li><li><a href="#aggregation-functions">Aggregation Functions</a></li><ul><li><a href="#how-to-define-group-by-aggregation-functions">How to define group-by aggregation functions?</a></li><li><a href="#how-to-define-simple-aggregation-functions">How to define simple aggregation functions?</a></li></ul><li><a href="#sort">sort</a></li><li><a href="#compute">compute</a></li><li><a href="#inner-join--left-join--right-join">inner-join / left-join / right-join</a></li><li><a href="#rolling-join-forwardrolling-join-backward">rolling-join-forward/rolling-join-backward</a></li></ul></ul>
    <h3 id="features">Features</h3><ul><li><p><strong>Unlimited size</strong><br />
Theoretically speaking, it supports dataset larger than memory to infinity!</p></li><li><p><strong>All native types</strong><br />
All the datatypes used to store data is native Clojure (or Java) types!</p></li><li><p><strong>From file to file</strong><br />
Integrate IO inside the dataframe. No need to write your own read-in and output functions!</p></li><li><p><strong>Distributed (coming soon)</strong><br />
Most operations could be distributed to different computers in a clusters. See the principle in <a href="http://www.onyxplatform.org/">Onyx</a>  <br /></p></li><li><p><strong>Lazy operations</strong><br />
Some operations will not be executed immediately. Dataframe will intelligently pipeline the operations altogether in computation.</p></li></ul><hr /><h3 id="basic-information">Basic Information</h3><ul><li>Most operations to the dataframe is performed lazily and all at once with <code>compute</code> except <code>sort</code> and <code>join</code>.</li><li>The dataframe process the data in rows, ie one row in one vector.</li><li>The input dataframe can be larger than memory in size.</li><li>By default, all columns have the same type: string. You are allowed to set its type, with our predefined type keywords.</li></ul><hr /><h2 id="api-documentation">API Documentation</h2><hr /><h4 id="reorder-col--rename-col">reorder-col / rename-col</h4><p>Reorder the columns / rename the column names in the dataframe</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>columns</code></td><td>Clojure.collection</td><td>The new set of column names</td><td>Should be existing headers in dataframe a if it is <code>reorderCol</code></td></tr></tbody></table><pre><code class="clojure">(rename-col y ["Employee" "EmployeeName" "new-Department" "Salary"])
(reorder-col y ["Employee" "new-Department" "EmployeeName" "Salary"])
</code></pre><hr /><h4 id="select-col">select-col</h4><p>Select columns to keep in the dataframe.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>columns</code></td><td>Clojure.collection</td><td>The set of columns names to keep</td><td>Should be existing columns within the dataframe</td></tr></tbody></table><pre><code class="clojure">(select-col y ["Employee" "Department"])
</code></pre><hr /><h4 id="delete-col">delete-col</h4><p>Eliminate columns in the dataframe.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>columns</code></td><td>Clojure.collection</td><td>The set of columns names to eliminate</td><td>Should be existing columns within the dataframe</td></tr></tbody></table><pre><code class="clojure">(delete-col y ["EmployeeName" "Salary"])
</code></pre><hr /><h4 id="filter">filter</h4><p>Filters the data frame by rows</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>columns</code></td><td>String / collection of strings</td><td>The columns the predicate function to apply to</td><td> </td></tr><tr><td><code>predicate</code></td><td>Function</td><td>The predicate function to determine if a row should be kept</td><td>This function should have the same number of arguments with the above columns and in the same order. Only rows that return <code>true</code> will be kept.</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(filter x "Salary" (fn [salary] (&lt;= salary 800)))
;; this statement deletes all the rows that have a salary larger than 800
(filter x ["Salary" "Department"] (fn [salary dept] (and (&lt;= salary 800) (= dept "computer science"))))
;; keeps only people from computer science department with salary not larger than 800
</code></pre><hr /><h4 id="set-type">set-type</h4><p>Set the type of a column. So when using the value of that column, it would be in that type.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>type</code></td><td>String</td><td>Type of the column</td><td>The native support types are: int, double, string, date. Note that by default all the column types are string. If you need special parsing function, see <code>add-parser</code>.</td></tr><tr><td><code>column</code></td><td>String</td><td>Target columns</td><td>Should be existing columns within the dataframe</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(set-type x "double" "Salary")
;; makes the column Salary doubles
</code></pre><hr /><h4 id="set-parser">set-parser</h4><p>A more flexible way to set type.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>parser</code></td><td>function</td><td>The parser function that will parse a string to other types (or even string)</td><td>The function should take only one argument which is a string, and the parsed type should be serializable.</td></tr><tr><td><code>column</code></td><td>String</td><td>Target columns</td><td>Should be existing columns within the dataframe</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(set-parser x Double/parseDouble "Salary")
;; parse all the values in Salary with this function
</code></pre><hr /><h4 id="operate-in-place-modification">operate (In-place modification)</h4><p><strong>In-place modification</strong> on a single column</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>operation</code></td><td>function</td><td>Function to be applied lazily</td><td>The function should take only one argument which is the value of the below column</td></tr><tr><td><code>column name</code></td><td>Keyword</td><td>Target columns</td><td>Should be existing columns within the dataframe</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(set-type x "double" "Salary")
(operate x - "Salary")
;; takes the negative of column Salary
</code></pre><hr /><h4 id="operate-column-generating">operate (Column generating)</h4><p>Calculate the result and store in a new column</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>operation</code></td><td>function</td><td>Function to be applied lazily</td><td>Argument number should be complied with the column names below, ie <em>if operation functions takes two arguments, the length of column names should also be 2, and in the same order to be passed to the function</em></td></tr><tr><td><code>column name(s)</code></td><td>String or collection of String</td><td>Target columns</td><td>Should be existing columns within the dataframe</td></tr><tr><td><code>new column</code></td><td>String</td><td>Resultant column</td><td>Should be new column other than the dataframe</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(operate x str ["Employee" "EmployeeName"] "new")
;; concats the two columns into the "new" column
</code></pre><hr /><h4 id="group-by">group-by</h4><p>Group by the dataframe with some columns (always use together with <code>aggregate</code>), or the result by applying the function to the column</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>groupby-keys</code></td><td>String / Collection</td><td>Group by columns (functions of columns)</td><td>Find the specification <a href="#groupby-keys">here</a></td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(group-by x ["Department" "DepartmentName"])
;; group by both columns
</code></pre><p><a name="groupby-keys"><strong>Group-by Keys Specification</strong></a></p><p><strong>Group-by functions requirements:</strong></p><ul><li>Take one argument</li><li>Return type: int / double / string</li></ul><p>One general rule is to put the group-by function and its corresponding column name together.</p><pre><code class="clojure">(defn rem10
  "Get the reminder of the num by 10"
  [num]
  (rem num 10))

(group-by x [rem10 "Salary"])
;; or
(group-by x [[rem10 "Salary"]])
</code></pre><p>If no group-by function, the column name can be alone.</p><pre><code class="clojure">(group-by x "Salary")
;; or
(group-by x ["Salary"])
</code></pre><p>You can also group by the combination of keys. (Use the above two rules together)</p><pre><code class="clojure">(group-by x [[rem10 "Salary"] "Department"])
;; or
(group-by x [[rem10 "Salary"] ["Department"]])
</code></pre><hr /><h4 id="aggregate">aggregate</h4><p>Aggregate the grouped dataframes with some functions. The aggregation function will be applied to every columns registered in sequence.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>aggregation function</code></td><td>function</td><td>Function to be applied to each column</td><td>Should take a collection as argument. And return one or a collection of predefined type*.</td></tr><tr><td><code>column name(s)</code></td><td>String or collection of String</td><td>Aggregate columns</td><td>Should be existing columns within the dataframe</td></tr><tr><td>[<code>new column</code>]</td><td>String or collection of string</td><td>Resultant column</td><td>Should be new columns not in the dataframe</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(aggregate x clojask/min ["Employee" "EmployeeName"] ["new" "new2"])
;; get the min of the two columns grouped by ...
</code></pre><h4 id="aggregation-functions">Aggregation Functions</h4><p>In Clojask, you can aggregate on the whole dataframe, or on the group-by dataframe. We call the first case "simple aggregation" and the second "group-by aggregation". Some given functions for simple aggregation are defined in namespace <code>clojask.api.aggregate</code>, and the given functions for group-by aggregation are defined in namespace <code>clojask.api.gb-aggregate</code>.</p><p>Below are full list of given functions for the two types.</p><p><code>clojask.api.aggregate</code>:</p><p><code>max</code>: Find the max value (use <code>clojure.core/compare</code> as the comparator)</p><p><code>min</code>: Find the min value (use <code>clojure.core/compare</code> as the comparator)</p><p><code>clojask.api.gb-aggregate</code>:</p><p><code>max</code>: Find the max value (use <code>clojure.core/compare</code> as the comparator)</p><p><code>min</code>: Find the min value (use <code>clojure.core/compare</code> as the comparator)</p><p>Besides these given functions, you are also welcomed to define your own.</p><h5 id="how-to-define-group-by-aggregation-functions">How to define group-by aggregation functions?</h5><p>This is the template:</p><pre><code class="clojure">(defn gb-aggre-template
  [col]  ;; take only one argument which is the aggregation column in the format of vector
  ;; ... your implementation
  result    ;; return one variable (could be int / double / string / collection of above)
  )
</code></pre><p>Basically, the function should take one argument only, which is the full aggregation column. <em><strong>Here we simply assume this column should be smaller than memory!</strong></em></p><p>You may find many built-in function in Clojure also fulfilling this requirement, for example, <code>count</code>, <code>mean</code>, and countless function constructed from <a href="https://clojuredocs.org/clojure.core/reduce"><code>reduce</code></a>.</p><h5 id="how-to-define-simple-aggregation-functions">How to define simple aggregation functions?</h5><p>This is the template:</p><pre><code class="clojure">(defn aggre-template
  ;; [new-value old-result]
  [old-result new-value]
  ;; old-result: the value of the result for the previous gb-aggre-template
  ;; new-value: the value for the column on the current row
  ;; ... your implementation
  new-result   ;; return the new result, and this will be passed as old-result for the next gb-aggre-template
  )
</code></pre><p><strong>Notes:</strong></p><ol><li>The old-result for the first <code>aggre-template</code> is <code>clojask.api.aggregate/start</code>. So your function must be able to deal with cases when the first argument is <code>clojask.api.aggregate/start</code>.</li><li>Your function should be self-sustainable, meaning that the result of <code>aggre-template</code> should be safe as the input for <code>aggre-template</code>.
<ol><li>To better understand the this template, you may refer to the documentation of <a href="https://clojuredocs.org/clojure.core/reduce"><code>reduce</code></a>, the <code>aggre-func</code> should be able to use in <code>reduce</code>.</li></ol></li></ol><hr /><h4 id="sort">sort</h4><p><strong>Immediately</strong> sort the dataframe</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>trending list</code></td><td>Collection (seq vector)</td><td>Indicates the sort order</td><td>Example: ["Salary" "+" "Employee" "-"] means that sort the Salary in ascending order, if equal sort the Employee in descending order</td></tr><tr><td><code>output-directory</code></td><td>String</td><td>The output path</td><td> </td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(sort y ["+" "Salary"] "resources/sort.csv")
;; sort by Salary ascendingly
</code></pre><hr /><h4 id="compute">compute</h4><p>Compute the result. The pre-defined lazy operations will be executed in pipeline, i.e. the result of the previous operation becomes the argument of the next operation.</p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>num of workers</code></td><td>int (max 8)</td><td>The number of worker instances (except the input and output nodes)</td><td>If this argument &gt;= 2, will use <a href="http://www.onyxplatform.org/">onyx</a> as the distributed platform</td></tr><tr><td><code>output path</code></td><td>String</td><td>The path of the output csv file</td><td>Could exist or not.</td></tr><tr><td>[<code>exception</code>]</td><td>boolean</td><td>Whether an exception during calculation will cause termination</td><td>Is useful for debugging or detecting empty fields</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(compute x 8 "../resources/test.csv" :exception true)
;; computes all the pre-registered operations
</code></pre><hr /><h4 id="inner-join--left-join--right-join">inner-join / left-join / right-join</h4><p>Inner / left / right join two dataframes by some columns</p><p><em>Remarks:</em></p><p><em>Join functions are immediate actions, which will be executed at once.</em></p><p><em>Will automatically pipeline the registered operations and filters like <code>compute</code>. You could think of join as first compute the two dataframes then join.</em></p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe a</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>dataframe b</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>a columns</code></td><td>Clojure.collection</td><td>The keys of a to be aligned</td><td>Should be existing headers in dataframe a</td></tr><tr><td><code>b columns</code></td><td>Clojure.collection</td><td>The keys of b to be aligned</td><td>Should be existing headers in dataframe b</td></tr><tr><td><code>number of workers</code></td><td>int (max 8)</td><td>Number of worker nodes doing the joining</td><td> </td></tr><tr><td><code>distination file</code></td><td>string</td><td>The file path to the distination</td><td>Will be emptied first</td></tr><tr><td>[<code>exception</code>]</td><td>boolean</td><td>Whether an exception during calculation will cause termination</td><td>Is useful for debugging or detecting empty fields</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(def x (dataframe "path/to/a"))
(def y (dataframe "path/to/b"))

(inner-join x y ["col a 1" "col a 2"] ["col b 1" "col b 2"] 8 "path/to/distination" :exception true)
;; inner join x and y

(left-join x y ["col a 1" "col a 2"] ["col b 1" "col b 2"] 8 "path/to/distination" :exception true)
;; left join x and y

(right-join x y ["col a 1" "col a 2"] ["col b 1" "col b 2"] 8 "path/to/distination" :exception true)
;; right join x and y
</code></pre><hr /><h4 id="rolling-join-forwardrolling-join-backward">rolling-join-forward/rolling-join-backward</h4><p>Rolling join two dataframes by columns</p><p><em>Remarks:</em></p><p><em>Join functions are immediate actions, which will be executed at once.</em></p><p><em>Will automatically pipeline the registered operations and filters like <code>compute</code>. You could think of join as first compute the two dataframes then join.</em></p><table><thead><tr><th>Argument</th><th>Type</th><th>Function</th><th>Remarks</th></tr></thead><tbody><tr><td><code>dataframe a</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>dataframe b</code></td><td>Clojask.DataFrame</td><td>The operated object</td><td> </td></tr><tr><td><code>a columns</code></td><td>Clojure.collection</td><td>The keys of a to be aligned</td><td>Should be existing headers in dataframe a</td></tr><tr><td><code>b columns</code></td><td>Clojure.collection</td><td>The keys of b to be aligned</td><td>Should be existing headers in dataframe b</td></tr><tr><td><code>number of workers</code></td><td>int (max 8)</td><td>Number of worker nodes doing the joining</td><td> </td></tr><tr><td><code>distination file</code></td><td>string</td><td>The file path to the distination</td><td>Will be emptied first</td></tr><tr><td>[<code>exception</code>]</td><td>boolean</td><td>Whether an exception during calculation will cause termination</td><td>Is useful for debugging or detecting empty fields</td></tr></tbody></table><p><strong>Example</strong></p><pre><code class="clojure">(def x (dataframe "path/to/a"))
(def y (dataframe "path/to/b"))

(rolling-join-forward x y ["Employee"] ["Employee"] "Salary" "Salary" 8 "resources/test.csv" :exception true)
(rolling-join-forward x y ["Employee"] ["Employee"] "Salary" "Salary" 8 "resources/test.csv" :exception true)
</code></pre>
</div>
<!--  -->
<!-- <br/> -->


    <!-- 
    <div id="prev-next">
    
    <a class="prev" href="/clojask-website/posts-output/examples/"><svg class="icon icon-circle-left"><use xlink:href="/clojask-website/img/icons.svg#icon-circle-left"></use></svg><div class="nav-text">Examples</div></a>
    
    
    <div class="next"></div>
    
</div>

     -->

    


</div>

            <!-- <hr/> -->
            <br/>
            <div id="footercont">
                Copyright &copy; 2021 Clojask
                <br>Powered by <a href="http://cryogenweb.org">Cryogen</a>
            </div>
        </article>

        <script src="/clojask-website/js/highlight.pack.js" type="application/javascript"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script src="/clojask-website/js.dropdown.js" type="application/javascript"></script> 
        

        
        
    </body>
</html>
